目前笔者主要使用的开发语言是python，java还在熟悉中，现阶段目标是刷题时可以使用java，以及看得懂dalao们讲解的java代码。

## 《java核心思想卷一》中提到的java语言基础:
### 不摸鱼啦! java学起来

## 《算法》第四版中提到的java语言基础:

java程序

![image]()

要创建静态方法库和定义数据类型，会用到下面五种语法，它们是Java语言的基础，也是大多数现代语言所共有的:
### 1. 原始数据类型：它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。
* 整型，及其算术运算符（int）；
* 浮点型，及其算术运算符（double）；
* 布尔型，它的值 {true, false}及其逻辑操作（boolean）；
* 字符型，它的值是你能够输入的英文字母数字字符和符号（char）。
   * 类型转换: 如果不会损失信息，数值会被自动提升为高级的数据类型。例如，在表达式 1+2.5中，1 会被转换为浮点数 1.0，表达式的值也为 double值 3.5。转换指的是在表达式中把类型名放在括号里将其后的值转换为括号中的类型。例如，(int)3.7的值是 3而 (double)3的值是 3.0。需要注意的是将浮点型转换为整型将会截断小数部分而非四舍五入，在复杂的表达式中的类型转换可能会很复杂，应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。
### 2. 语句：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。
Java 程序是由语句组成的。我们会使用六种语句：声明、赋值、条件、循环、调用和返回。语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。
* 声明语句：创建某种类型的变量并用标识符为其命名。Java 是一种**强类型**的语言，因为 Java编译器会检查类型的一致性
* 赋值语句：将（由表达式产生的）某种类型的数值赋予一个变量。Java 还有一些隐式赋值的语法可以使某个变量的值相对于当前值发生变化，例如将一个整型值加 1。
  * 递增 / 递减运算符，++i; 等价于 i=i+1; 且表达式为 i+1;。类似地，--i; 等价于 i=i-1;i++;。和 i--;的意思相同，只是表达式的值为 i的值。
  * 其他复合运算符，在赋值语句中将一个二元运算符写在等号之前，等价于将左边的变量放在等号右边并作为第一个操作数。例如，i/=2;等价于 i=i/2;。注意，i += 1;等价于 i = i + 1;（以及 ++i;）。
* 条件语句：能够简单地改变执行流程——根据指定的条件执行两个代码段之一。
* 循环语句：更彻底地改变执行流程——只要条件为真就不断地反复执行代码段中的语句。
* 调用和返回语句：和静态方法有关，是改变执行流程和代码组织的另一种方式。程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。
### 3. 数组：数组是多个同种数据类型的值的集合。
  ![image]()
### 4. 静态方法：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。
* 编写递归方法时最重要的几点:
   1) 递归总有一个最简单的情况——方法的第一条语句总是一个包含 return的条件语句。
   2) 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。
   3) 递归调用的父问题和尝试解决的子问题之间不应该有交集。
### 5. 字符串：字符串是一连串的字符，Java 内置了对它们的一些操作。
* Java 在连接字符串的时候会自动将任意数据类型的值转换为字符串：如果加号（+）的一个参数是字符串，那么 Java 会自动将其他参数都转换为字符串（如果它们不是的话）。除了像 "The square root of 2.0 is " + Math. sqrt(2.0)这样的使用方式之外，这种机制也使我们能够通过一个空字符串 ""将任意数据类型的值转换为字符串值。
### 6. 标准输入 / 输出：标准输入输出是程序与外界联系的桥梁。
### 7. 数据抽象：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。
### 第一个java例程，二分查找
```java
import java.util.Arrays;
public class BinarySearch 
{
 public static int rank(int key, int[] a)  
   {  // 数组必须是有序的
    int lo  = 0;
    int hi = a.length - 1;
    while (lo <= hi)
       {  // 被查找的键要么不存在，要么必然存在于 a[lo..hi]之中
          int mid = lo + (hi - lo) / 2;
          if      (key < a[mid]) hi = mid - 1; 
          else if (key > a[mid]) lo = mid + 1;  
          else                     return mid;
       }
        return -1;
   } 
 public static void main(String[] args)  
  {
    int[] whitelist = In.readInts(args[0]);  
    Arrays.sort(whitelist);
    while (!StdIn.isEmpty())
    {  // 读取键值，如果不存在于白名单中则将其打印
    int key = StdIn.readInt();
    if (rank(key, whitelist) < 0)
       StdOut.println(key);
    }
  }
}
```
