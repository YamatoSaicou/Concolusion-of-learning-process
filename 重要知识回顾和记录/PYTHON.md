# Python

## 啥是python

1. Python是一门解释性语言吗？
  * 做笔试题的时候，要这么选（
  * 什么是解释性语言和编译性语言？
    * 计算机是不能够识别高级语言的，所以当我们运行一个高级语言程序的时候，就需要一个“翻译机”来从事把高级语言转变成计算机能读懂的机器语言的过程。这个过程分成两类，第一种是编译，第二种是解释。
    * 编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序转变成机器语言。运行时就不需要翻译，而直接执行就可以了。最典型的例子就是C语言。
    * 解释型语言就没有这个编译的过程，而是在程序运行的时候，通过解释器对程序逐行作出解释，然后直接运行，最典型的例子是Ruby。
    * Python是编译+解释型的语言，执行的时候是由Python解释器，逐行编译+解释，然后运行，因为在运行的过程中，需要编译+解释，所以Python的运行性能会低于编译型语言，比如C++。为了提高性能，Python解释器，会将模块（以后要重用的脚本文件放在模块里）的编译+解释的结果，保存在.pyc中。这样下次执行的时候，就省了编译这个环节。提高性能。一次性的脚本文件，解释器是不会保存编译+解释的结果，也就是没有.pyc文件。
2. 为啥说python“简单”？
  * 高层语言：用Python语言编写程序的时候无需考虑诸如如何管理你的程序使用的内存一类的底层细节。
  * 丰富的库
  * 语法简单
## 重要的特性

**1.迭代器和生成器** 

理解generators前还要理解iterables

**Iterables**

当你创建了一个列表,你可以一个一个的读取它的每一项,这叫做iteration:

```text
>>> mylist = [1, 2, 3]
>>> for i in mylist:
...    print(i)
1
2
3
```

Mylist是可迭代的.当你用列表推导式的时候,你就创建了一个列表,而这个列表也是可迭代的:

```text
>>> mylist = [x*x for x in range(3)]
>>> for i in mylist:
...    print(i)
0
1
4
```

所有你可以用在`for...in...`语句中的都是可迭代的:比如lists,strings,files...因为这些可迭代的对象你可以随意的读取所以非常方便易用,但是你必须把它们的值放到内存里,当它们有很多值时就会消耗太多的内存.

**Generators**

生成器也是迭代器的一种,但是你**只能迭代它们一次**.原因很简单,因为它们不是全部存在内存里,它们只在要调用的时候在内存里生成:

```text
>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator:
...    print(i)
0
1
4
```

生成器和迭代器的区别就是用`()`代替`[]`,还有你不能用`for i in mygenerator`第二次调用生成器:程序首先计算0,然后会在内存里丢掉0去计算1,直到计算完4.

**2.\*args and \*\*kwargs**

用`*args`和`**kwargs`只是为了方便并没有强制使用它们.

当你不确定你的函数里将要传递多少参数时你可以用`*args`.它可以传递任意数量的参数:

相似的,`**kwargs`允许你使用没有事先定义的参数名:

当调用函数时你也可以用`*`和`**`语法.例如:

```text
>>> def print_three_things(a, b, c):
...     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)
...
>>> mylist = ['aardvark', 'baboon', 'cat']
>>> print_three_things(*mylist)

a = aardvark, b = baboon, c = cat
```

就像你看到的一样,它可以传递列表\(或者元组\)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用\*.

3.[**装饰器**](https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584)

4.[**Python中单下划线和双下划线**](http://www.zhihu.com/question/19754941)

5.[**Python代码的执行原理**](https://www.cnblogs.com/xiaolongxia/articles/4039135.html)

6.[**Python中int是如何实现的**](http://python.jobbole.com/82632/)

7.**Python中的gil**

GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大。

8.[**Python中的协程**](https://www.cnblogs.com/zingp/p/5911537.html)

9.[**Python的IO多路复用**](https://www.cnblogs.com/wjx1/p/5114309.html)

10.[**上下文管理器**](https://blog.csdn.net/weixin_38853600/article/details/82887907)

11.[**运算符重载**](https://blog.csdn.net/zss041962/article/details/78917359)

12.闭包

内部函数可以使用外部函数的临时变量。
```python

 #修改闭包变量的实例
 #  outer是外部函数 a和b都是外函数的临时变量
def outer( a ):
     b = 10  # a和b都是闭包变量
     c = [a] #这里对应修改闭包变量的方法2
     # inner是内函数
     def inner():
         #内函数中想修改闭包变量
         # 方法1 nonlocal关键字声明
         nonlocal b
         b = a + b
         # 方法二，把闭包变量修改成可变数据类型 比如列表
         c[0] += 1
         print(c[0])
         print(b) # 函数的返回值是内函数的引用
     return inner

if __name__ == '__main__':

     demo = outer(5)
     demo()
```

13.[**元类**](http://python.jobbole.com/88795/)

14.[**单例模式**](https://www.cnblogs.com/huchong/p/8244279.html)

15.[**多重继承**](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000)

16.**浅拷贝和深拷贝**

**浅拷贝**

1) 对于不可变类型 Number String Tuple,浅拷贝**仅仅是地址指向**，不会开辟新空间。

2) 对于可变类型 List、Dictionary、Set，浅拷贝会开辟新的空间地址(仅仅是最顶层开辟了新的空间，里层的元素地址还是一样的)。

3) 浅拷贝后，改变原始对象中为可变类型的元素的值，会同时影响拷贝对象的；改变原始对象中为不可变类型的元素的值，只有原始类型受影响。（操作拷贝对象对原始对象的也是同理）

**深拷贝**

1) 浅拷贝，除了顶层拷贝，还对子元素也进行了拷贝（本质上递归浅拷贝）

2) 经过深拷贝后，原始对象和拷贝对象所有的子元素地址都是独立的了

浅拷贝与深拷贝的不同之处对比的例子：
```python
import copy                         # 导入 copy 模块

list1_1 = [0, 1, 2, ['a', 'b']]
list1_2 = list1_1                   # 赋值
list1_3 = list1_1.copy()            # 浅拷贝;同 list1_3 = list1_1[:]
list1_4 = copy.copy(list1_1)        # 浅拷贝
list1_5 = copy.deepcopy(list1_1)    # 深拷贝

list1_1.append(4)                   # 在 list1_1 末尾添加一个元素 4
list1_1[3].append('c')              # 向 list1_1 中内嵌的列表末尾添加一个元素 'c'

print("list1_1' =", list1_1)    #list1_1' = [0, 1, 2, ['a', 'b', 'c'], 4]
print("list1_2' =", list1_2)    #list1_2' = [0, 1, 2, ['a', 'b', 'c'], 4]
print("list1_3' =", list1_3)    #list1_3' = [0, 1, 2, ['a', 'b', 'c']]
print("list1_4' =", list1_4)    #list1_4' = [0, 1, 2, ['a', 'b', 'c']]
print("list1_5' =", list1_5)    #list1_5' = [0, 1, 2, ['a', 'b']]

```

**最后强调一点，对象赋值实际上是简单的对象引用**

17.[**垃圾回收机制**]

 1. Python语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』。
   * 『引用计数法』的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。
   * 它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是**它不能解决对象的“循环引用”**，因此，也有很多语言比如Java并没有采用该算法做来垃圾的收集机制。
 2. 引用计数法的详细运作：
   * 导致引用计数+1的情况
     * 对象被创建，例如a=23
     *  对象被引用，例如b=a
     *  对象被作为参数，传入到一个函数中，例如func(a)
     *  对象作为一个元素，存储在容器中，例如list1=[a,a]
   * 导致引用计数-1的情况
     * 对象的别名被显式销毁，例如del a
     * 对象的别名被赋予新的对象，例如a=24
     * 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
     * 对象所在的容器被销毁，或从容器中删除对象
 3. 分代回收
   * 分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。
   * 新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。
   * 分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象

18.[**保护类中元素的装饰器@property**](https://www.liaoxuefeng.com/wiki/897692888725344/923030547069856)

19.[**\_\_slots\_\_**](https://www.liaoxuefeng.com/wiki/897692888725344/923030542875328)

正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。

使用slots可以限制允许绑定的方法和实例。
```python
    class Student(object):
        __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```
20. **import**

**import的基本用法**

 1. 导入包名
 
```
 import os
```

 2. 从包中导入函数
```
 from math import pow
```

 3. 导入包并赋予别名
```
 import math as m
```
 4. 从包中导入常量并赋予别名
```
 from math import pi as p
```
 5.导入包中所有内容
```
 from math import *
```
 **Python组织代码的方式**
 * 一个文件中的元素: 如果整个程序只有一个文件，这个文件中就有变量、函数、类这些元素可供操作。
 * 模块(module): 简单来说模块就是一个.py文件，例如：在同一个路径下有a.py和b.py两个文件，那么在a.py中就可以import b，然后通过b.xxx就可以使用b.py中的变量、函数、类。
 * 包(package): 简单理解包就是包含一个__init__.py的文件夹，例如：在同一个路径下有一个a.py文件和一个b文件夹，在b文件夹中有一个__init__.py文件，在a中import b就是导入了b这个包

 **使用import语句就可以将模块导入。系统在导入模块时，要做以下三件事：**

 1. 为源代码文件中定义的对象创建一个名字空间，通过这个名字空间可以访问到模块中定义的函数及变量。

 2. 在新创建的名字空间里执行源代码文件.

 3. 创建一个名为源代码文件的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量
