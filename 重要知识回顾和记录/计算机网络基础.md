# 计算机网络
## 网络模型

1.四层模型，以及应用在每一层上的常见关协议。

**应用层**

HTTP 超文本传输协议<br>
FTP 文件传输协议<br>
SMTP 简单邮件传输协议<br>
SOCKS 安全套接字协议<br>
DNS 域名系统<br>
NFS网络文件系统协议<br>
DHCP动态主机配套协议(基于UDP)<br>
SSL 安全套接字层协议<br>

**传输层**

TCP传输控制协议<br>
UDP用户数据报协议<br>
RUDP可靠的用户数据报协议<br>
Mobile IP 移动IP协议<br>

**网络层**

IP/IPv6 互联网协议/互联网协议第六版<br>

**数据链路层**

ARP地址解析协议<br>
RARP逆向地址解析协议<br>

2. OSI七层协议

**应用层**

网络服务与最终用户的一个接口。

**表示层**

数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）

**会话层**

建立、管理、终止会话。（在五层模型里面已经合并到了应用层）

**传输层**

定义传输数据的协议端口号，以及流控和差错校验。

**网络层**

进行逻辑地址寻址，实现不同网络之间的路径选择。

**数据链路层**

建立逻辑连接、进行硬件地址寻址、差错校验 [2]  等功能。（由底层网络定义协议）
将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。

**物理层**
建立、维护、断开物理连接。（由底层网络定义协议）


## IP相关

 IP地址 = 网络地址 + 主机地址(又称：主机号和网络号组成)
 
 IP地址 192.168.1.168, 子网掩码 255.255.255.0(下文有详解) 为例,  这个地址实际上是两部分:
    * 192.168.1.168（IP地址） = 192.168.1.0 (网络地址) + 0.0.0.168（主机地址）

![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/子网.png)

### IP地址与MAC地址:

1.MAC地址
MAC（Media Access Control，介质访问控制）地址，或称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。MAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。

  1. 前24位叫做组织唯一标志符（Organizationally Unique Identifier，即OUI），是由IEEE的注册管理机构给不同厂家分配的代码，区分了不同的厂家。
  2. 后24位是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中MAC地址后24位是不同的。

2.IP地址
IP地址（Internet Protocol Address），缩写为IP Adress，是一种在Internet上的给主机统一编址的地址格式，也称为网络协议（IP协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的IP地址，分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；如无特别注明，一般我们讲的的IP地址所指的是IPv4。

3.IP地址与MAC地址的关系
IP地址专注于网络层，网络层设备（如路由器）根据IP地址，将数据包从一个网络传递转发到另外一个网络上；而MAC地址专注于数据链路层，数据链路层设备（如交换机）根据MAC地址，将一个数据帧从一个节点传送到相同链路的另一个节点上。IP和MAC地址这种映射关系由ARP（Address Resolution Protocol，地址解析协议）协议完成，ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络。

### IP地址的组成

## TCP与UDP

TCP报文中重要的几个标志位：

1. 序列号seq: 占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生，给字节编上序号后，就给每一个报文段指派一个序号，序列号seq就是这个报文段中的第一个字节的数据编号。
2. 确认号ack: 占4个字节，期待收到对方下一个报文段的第一个数据字节的序号，序列号表示报文段携带数据的第一个字节的编号，而确认号指的是期望接受到下一个字节的编号，最后一个字节的编号+1即是确认号。
3. 确认ACK: 占1个比特位，仅当ACK=1，确认号字段才有效。ACK=0，确认号无效。
4. 同步SYN: 连接建立时用于同步序号。当SYN=1，ACK=0表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使用SYN=1，ACK=1.因此，SYN=1表示这是一个连接请求，或连接接收报文，SYN这个标志位只有在TCP建立连接才会被置为1，握手完成后SYN标志位被置为0.
5. 终止FIN: 用来释放一个连接。

### 三次握手和四次挥手图解:

1.三次握手的过程

![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/sanci.png)

  1. 第一次握手: 建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）
  2. 第二次握手: 服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）
  3. 第三次握手: 客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。
  4. 未连接队列: 在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包(syn=j)开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包时，删除该条目，服务器进入ESTAB_LISHED状态。

2.四次挥手
![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/sici.png)
  1. 第一次挥手: 首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。
  2. 第二次挥手: 服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。
  3. 第三次挥手: 关闭服务器到客户端的连接，发送一个FIN给客户端。
  4. 第四次挥手: 客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。客户端发送FIN后，进入终止等待状态，服务器收到客户端连接释放报文段后，就立即给客户端发送确认，服务器就进入CLOSE_WAIT状态，此时TCP服务器进程就通知高层应用进程，因而从客户端到服务器的连接就释放了。此时是“半关闭状态”，即客户端不可以发送给服务器，服务器可以发送给客户端。此时，如果服务器没有数据报发送给客户端，其应用程序就通知TCP释放连接，然后发送给客户端连接释放数据报，并等待确认。客户端发送确认后，进入TIME_WAIT状态，但是此时TCP连接还没有释放，然后经过等待计时器设置的2MSL后，才进入到CLOSED状态。

**为什么需要2MSL时间？**

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

**为什么不能用两次握手进行连接？**

答：把三次握手改成仅需要两次握手,会造成
1. 死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。
2.正常情况下，A发出连接请求，但是因为连接报文请求丢失而未收到确认，于是A再重传一次连接请求，后来收到了请求，并收到了确认，建立了连接，数据传输完毕后，就释放链接，A共发送了两次连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”，但是还有异常情况下，A发送的请求报文连接段并没有丢失，而是在某个网络节点滞留较长时间，以致延误到请求释放后的某个时间到达B，本来是一个早已失效的报文段，但是B收到了此失效连接请求报文段后，就误以为A又重新发送的连接请求报文段，并发送确认报文段给A，同意建立连接，如果没有三次握手，那么B发送确认后，连接就建立了，而此时A没有发送建立连接的请求报文段，于是不理会B的确认，也不会给B发送数据，而B却一直等待A发送数据，因此B的许多资源就浪费了，采用三次握手的方式就可以防止这种事情发生
  
**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

答：建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

### TCP与UDP的区别

1. UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。 即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序
	1. UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
	2. 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。
	3. UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
	4. 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。 
	5. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
	6. UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。
 
2. TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。
	1. 累计确认: 首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，它可以保证可靠性。
	2. 快速重传: 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 
	3. 流量控制: 通过滑动窗口和累计确认来实现。整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数。这称为发送窗口，有时也称为窗口。
  * TCP buffer中的数据分为以下四类，并把它们看作一个时间轴：
    * 已发送已确认数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。如下图所示，31个字节已经发送并确认。
    * 已发送但尚未确认 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。下图所示14字节为第2类。
    * 未发送而接收方已Ready 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。
    * 未发送而接收方Not Ready 由于接收方not ready，还不允许将这部分数据发出。
  * 发送窗口上限 = min(接收端窗口，拥塞窗口)
	4. 拥塞控制:有四种方法，分别是:
  * 慢开始: 
    * 当主机开始发送数据时，如果立即将大量数据字节注入到网络，那么就有可能因为不清楚当前网络的负荷情况而引起网络阻塞。所以，最好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚发送报文段时，先把拥塞窗口cwnd设置为1，收到确认后为2，然后为4，8.....指数级增长。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。（慢开始当中的“慢”并不是指cwnd的增长速率慢，而是在TCP开始发送报文段时先设置cwnd = 1,使得发送方在开始时只发送一一个报文段）
    * 当rwnd足够大的时候，为了防止拥塞窗口cwnd的增长引起网络阻塞，还需要另外一个变量------慢开始门限ssthresh.当cwnd < ssthresh时，使用上述慢启动算法；当cwnd >ssthresh时，停止使用慢启动算法，改用拥塞避免算法   
    * 拥塞避免: 让拥塞窗口cwnd缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口cwnd按线性规律缓慢的增长，比慢开始算法的拥塞窗口增长速率缓慢的多。无论是慢启动算法还是拥塞避免算法，**只要判断网络出现拥塞，就要把慢启动开始门限（ssthresh）设置为发送窗口的一半**（>=2），cwnd设置为1，然后再使用慢启动算法，这样做的目的能迅速的减少网络当中的数据传输，使发生拥塞的路由器能够把队列中堆积的分组处理完毕。
  * 快重传: 上面讲过了。
   
  * 快恢复: 当发送方连续收到三个重复确认时，执行快恢复算法，拥塞窗口cwnd变为原来的一般，慢启动门限变为现在的cwnd。由于发送方现在认为网络很可能没有发生阻塞，因此现在不执行慢启动算法，而是把cwnd值设置为慢启动门限减半后的值，然后开始执行拥塞避免算法，拥塞窗口cwnd值线性增大。

3. 小结:
	1. 基于连接与无连接；
	2. 对系统资源的要求（TCP较多，UDP少）；
	3. UDP程序结构较简单；
	4. 流模式与数据报模式 ；
	5. TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。
 
4. socket编程

* TCP编程的服务器端一般步骤是： 
  1. 创建一个socket，用函数socket()； 
  2. 设置socket属性，用函数setsockopt(); * 可选 
  3. 绑定IP地址、端口等信息到socket上，用函数bind(); 
  4. 开启监听，用函数listen()； 
  5. 接收客户端上来的连接，用函数accept()； 
  6. 收发数据，用函数send()和recv()，或者read()和write(); 
  7. 关闭网络连接； 
  8. 关闭监听；

* TCP编程的客户端一般步骤是： 
  1. 创建一个socket，用函数socket()； 
  2. 设置socket属性，用函数setsockopt();* 可选 
  3. 绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
  4. 设置要连接的对方的IP地址和端口等属性； 
  5. 连接服务器，用函数connect()； 
  6. 收发数据，用函数send()和recv()，或者read()和write(); 
  7. 关闭网络连接；
  
  * UDP编程的服务器端一般步骤是： 
  1. 创建一个socket，用函数socket()； 
  2. 设置socket属性，用函数setsockopt();* 可选 
  3. 绑定IP地址、端口等信息到socket上，用函数bind(); 
  4. 循环接收数据，用函数recvfrom(); 
  5. 关闭网络连接； 

  * UDP编程的客户端一般步骤是： 
  1. 创建一个socket，用函数socket()； 
  2. 设置socket属性，用函数setsockopt();* 可选 
  3. 绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
  4. 设置对方的IP地址和端口等属性; 
  5. 发送数据，用函数sendto(); 
  6. 关闭网络连接；
```python
# socket server
from socket import socket, SOCK_STREAM, AF_INET
from datetime import datetime
def main():
    # 1.创建套接字对象并指定使用哪种传输服务
    # family=AF_INET - IPv4地址
    # family=AF_INET6 - IPv6地址
    # type=SOCK_STREAM - TCP套接字
    # type=SOCK_DGRAM - UDP套接字
    # type=SOCK_RAW - 原始套接字
    server = socket(family=AF_INET, type=SOCK_STREAM)
    # 2.绑定IP地址和端口(端口用于区分不同的服务)
    # 同一时间在同一个端口上只能绑定一个服务否则报错
    server.bind(('localhost', 6789))
    # 3.开启监听 - 监听客户端连接到服务器
    # 参数512可以理解为连接队列的大小
    server.listen(512)
    print('服务器启动开始监听...')
    while True:
        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)
        # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行
        # accept方法返回一个元组其中的第一个元素是客户端对象
        # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)
        client, addr = server.accept()
        print(str(addr) + '连接到了服务器.')
        # 5.发送数据
        client.send(str(datetime.now()).encode('utf-8'))
        # 6.断开连接
        client.close()
if __name__ == '__main__':
    main()
```python
# socket client
from socket import socket
def main():
    # 1.创建套接字对象默认使用IPv4和TCP协议
    client = socket()
    # 2.连接到服务器(需要指定IP地址和端口)
    client.connect(('localhost', 6789))
    # 3.从服务器接收数据
    print(client.recv(1024).decode('utf-8'))
    client.close()
if __name__ == '__main__':
    main()
```
## HTTP相关

1. http与https的区别 [点这里](https://www.cnblogs.com/wqhwe/p/5407468.html)

2. http1/1.1/2的区别 [点这里](https://blog.csdn.net/zhglance/article/details/76162176)

3. http常见状态码: 
* 1XX代表通知，2XX代表成功，3XX代表重定向，4XX代表客户端出错，5XX代表服务端出错
* 200 OK（成功） 请求成功完成
* 201 Created（已创建） 请求成功完成并创建了一个新资源
* 204("No Content") 重要程度：高。 若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。服务器也可以对GET请求返回此响应代码，这表明“客户端请求的资源存在，但其表示是空的”。注意与304("Not Modified")的区别。204常常用在Ajax应用里。服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素
* 301 Moved Permanently （永久移动） 请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
* 302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
* 304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
* 400 Bad request（坏请求） 请求不可用或不一致
* 401 Unauthorized（未授权） 请求未包含认证信息
* 403 Forbidden（禁止） 请求中发送的认证密令无权访问目标
* 404 Notfound（未找到） URL 对应的资源不存
* 405 Method not allowed（不允许使用的方法） 指定资源不支持请求使用的方法
* 500 Internal server error（内部服务器错误） 处理请求的过程中发生意外错误
* 更加详细的解释[点这里](https://www.cnblogs.com/xflonga/p/9368993.html)
4. GET POST 等的区别:
* GET和POST本质上两者没有任何区别。他们都是HTTP协议中的请求方法。底层实现都是基于TCP/IP协议
* 协议语义是这两个HTTP方法最根本最本质的区别。GET是用来向获取服务器信息的，请求报文传输的信息只是用于描述所需资源的参数，返回的信息才是数据本身；POST是用来向服务器传递数据的，其请求报文传递的信息就是数据本身，返回的报文只是操作的结果。
* POST是一个可能有副作用的方法，但GET应是没有副作用的的。
   * 安全(Safe)指的是是否改变服务器资源的状态，即是我们平常说的有无副作用。因为提交数据的目的往往是为了改变服务器状态，所以POST不是安全的(Safe)；而GET是为了获取数据，所以他不应该改变服务器的状态，是安全的(Safe)。HTTP中的安全Safe(副作用)和大多数人平时想的安全Security(例如数据安全)，仅仅是共用一个中文词汇
   * 如果你有任何安全上的需求，请先上HTTPS，POST不保证你的请求是安全的(Security)。
* 一般而言URL中的路径和查询字符串(俗称GET参数)组件是GET方法是向服务器提供资源描述信息的最主要途径。
* 请求的body段则是POST方法向服务器传递数据的途径。
* 安全(Safe)方法包括GET都是可被缓存的，POST不会。使用GET，你可能会有意无意就享受到从浏览器到代理到网络服务商再到服务器各个网络组件一层一层的透明缓存；而POST默认是不可缓存的,需要你显式使用缓存相关Header。
5. 缓存：缓存分为俩种，强缓存和协商缓存。http缓存主要针如css，js，图片等更新频率不大的静态文件
* Http缓存头中的关键字段:
   * Cache-Control请求/响应头，缓存控制字段，可以说是控制http缓存的最高指令，要不要缓存也是它说了算。
   * Expires 响应头，代表资源过期时间，由服务器返回提供，GMT格式日期
   * Last-Modified 响应头，资源最新修改时间，由服务器告诉浏览器。
   * if-Modified-Since 请求头，资源最新修改时间，由浏览器告诉服务器(其实就是上次服务器给的Last-Modified，请求又还给服务器对比)，和Last-Modified是一对，它两会进行对比。
   * Etag 响应头，资源标识，由服务器告诉浏览器。
   * if-None-Match 请求头，缓存资源标识，由浏览器告诉服务器(其实就是上次服务器给的Etag)，和Etag是一对，它两会进行对比。
* 强缓存：直接从本地缓存中取资源，不会和服务器通信（由Expire和cache-control控制且后者优先级高于前者）
* 协商缓存：通过服务器来告知是否使用缓存，核对缓存文件是否为最新。
  * 1.浏览器地址栏回车，或者点击跳转按钮，前进，后退，新开窗口，这些行为，会让Expires，max-age生效，也就是说，这几种操作下，浏览器会判断过期时间，再考虑要不要发起请求，当然Last-Modified和Etag也有效。
  * 2.F5刷新浏览器，或者使用浏览器导航栏的刷新按钮，这几种，会忽略掉Expires，max-age的限制，强行发起请求，Last-Modified和Etag在这种情况下也有效。
  * 3.CTRL+F5是强制请求，所有缓存文件都不使用，全部重新请求下载，因此Expires，max-age，Last-Modified和Etag全部失效。
6. Cache session cookie:
* Cookie是保存客户端的一组数据，主要用来保存用户的个人信息，主要存放浏览器请求服务器时的请求信息，这些信息是非敏感信息。主要用于当用户访问您的系统时，应用程序可以检索以前存储的信息。
* Session是由应用服务器维持的一个服务器端的存储空间，是一种保存上下文信息的机制，它是针对每一个用户的。用户在连接服务器时，服务器会生成一个唯一的SessionID，用该SessionID为标识符来存取服务器端的Session存储空间，面SessionID这一数据是以Cookie形式保存在客户端。用户提交页面时，会将SessionID提交到服务器端，来存取Session数据。
    * 通常Session-Cookie是不能跨窗口使用的，当你新开了一个浏览器窗口进入相同页面时，系统会赋予你一个新的SessionID，这样我们信息共享的目的就达不到了，此时我们可以先把SessionID保存在Persistent-Cookie中，然后在新窗口中读出来，就可以得到上一个窗口SessionID了，这样通过Session-Cookie和Persistent-Cookie的结合我们就实现了跨窗口的Session-Tracking（会话跟踪）。
* Cache存储于服务器的内存中，允许您自定义如何缓存数据项，以及缓存多长时间。当系统缺乏内存时，缓存会自动移除很少使用的或优先级较低的缓存项，以释放内存，此过程称为清理。这是缓存为了确保过期数据不再占用宝贵的服务器资源的方式之一。它不与会话相关，所以它是多会话共享的，因此缓存可以提高系统性能。同时有可能会泄露用户信息，另外在获取数据时还需要检测该缓存项是否还存在。
## 其他协议
1. DNS协议
2. NAT协议
3. DHCP协议
4. 路由选择协议
5. ARP协议
