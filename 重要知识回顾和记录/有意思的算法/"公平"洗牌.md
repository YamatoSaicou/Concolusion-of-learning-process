## 设计一个公平的洗牌算法
对于一个洗牌算法来说，什么叫**公平**？ <br>

洗牌的结果是所有元素的一个排列。一副牌如果有 n 个元素，最终排列的可能性一共有 n! 个，公平的洗牌算法，应该能等概率地给出这 n! 个结果中的任意一个。但是如果我们计算出所有的可能性，在工程上不可能，这个算法的时间复杂度将会是O(n!)。<br>

因此，我们换一个角度来思考，什么是“公平”？ 公平是指，**对于生成的排列，每一个元素都能独立等概率地出现在每一个位置**。或者反过来，每一个位置都能独立等概率地放置每个元素。<br>

这段python代码就做到了这个“公平”：

```python
   for(int i = len(arr) - 1, i >= 0, i = i - 1):
       swap(arr[i],arr[rand(0, i)])  #rand(0,i) 负责生成0-i的随机一个整数（包括0和i），并且要求rand产生的随机无偏
```
这段代码做了什么呢？很简单，i 从后向前，每次随机一个 [0...i] 之间的下标，然后将 arr[i] 和这个随机的下标元素，也就是 arr[rand(0， i)] 交换位置。<br>

可以用数学归纳法证明：第Z（Z<=N)次计算时每张牌出位位置的概率为1/Z<br>

第一次计算时第一张牌(i=0)出现在第一个位置的概率为1。<br>

第二次计算时第二张牌(i=1)很明显出现在两个位置中的概率都是1/2。<br>

我们就是要证明第Z（Z<=N)次计算时每张牌出位位置的概率为1/Z<br>

1. 很明显Z=1时结论成立。<br>

2. 假设当Z = K时结论也成立。<br>

当Z=K+1时，易知第Z张牌出现在任意位置的概率为1/Z。<br>

前K个数能够保留当前位置的概率为（1 - 1/(K+1)), 那么任意一张牌出现在任意位置的概率为(1/K) *（1 - 1/(K+1)) = 1/(K+1)。<br>

3. 同样当Z=N时该算法也成立。<br>
