## 总结

![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/paixu.png)

### 选择排序

#### 最好、最差和平均时间复杂度都是O(n2)
#### 选择排序是不稳定

动态图演示（图来源自公众号：五分钟学算法）
![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/xuanze.gif)

### 插入排序

两重循环，最差和平均时间复杂度为O(n2)，最好情况是原序列已有序，则忽略内层循环，时间复杂度O(n)。插入排序是稳定的。

内层循环我们用的是从后向前遍历，来找到合适的插入位置，而内层循环所遍历的，是已排序的数组，所以我们可以使用二分查找来寻找插入位置，从而使时间复杂度简化到O(n*log n)。

动态图演示（图来源自公众号：五分钟学算法）
![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/charu.gif)

### 冒泡排序

冒泡排序与简单选择排序类似，无论如何都要执行完两重循环。
#### 最好、最坏和平均时间复杂度均为O(n2)，不需要额外空间。冒泡排序是稳定的。

冒泡排序的一个**改进**是，在内层循环之前设置一个标记变量，用于标记循环是否进行了交换，在内层循环结束时，若判断没有进行交换，则说明剩下的序列中，每个元素都小于等于后面一个元素，即已经有序，可终止循环。这样，冒泡排序的最好时间复杂度可以提升到O(n)。

动态图演示（图来源自公众号：五分钟学算法）

![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/maopao.gif)

### 希尔排序

### 归并排序

### 快速排序

快排的思想是，选取第一个数为基准，通过一次遍历将小于它的元素放到它的左侧，将大于它的元素放到它的右侧，然后对它的左右两个子序列分别递归地执行同样的操作。最好和平均实际复杂度为O(nlogn)，但是，如果选取基准的规则正好与实际数值分布相反，例如我们选取第一个数为基准，而原始序列是倒序的，那么每一轮循环，快排都只能把基准放到最右侧，故快排的最差时间复杂度为O(n2)。**快速排序是不稳定的**。

动态图演示（图来源自公众号：五分钟学算法）
![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/kuaipai.gif)

### 堆排序

动态图演示（图来源自公众号：五分钟学算法）
![image](https://github.com/YamatoSaicou/Kancolle-wallpaer/blob/master/gif/duipai.gif)




