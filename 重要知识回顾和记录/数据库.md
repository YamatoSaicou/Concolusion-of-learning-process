# 关系型数据库
## 三大范式
1. 所有的字段值都是不可分解的原子值。
2. 非键字段必须依赖与主键。
3. 消除传递依赖，每列数据必须与主键直接相关。
## 事务与并发

### 1.事务的特性

事务（transaction）是由指逻辑上对数据的的一组操作。

1. 原子性：事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库，失败则不能对数据库产生影响；

2. 一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

3. 隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离；

4. 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。

### 2.隔离性

隔离性：当多个线程都开启事务来操作数据库中的数据时，数据库系统要进行隔离操作，以保证各个线程获取数据的准确性。

1. 数据访问冲突的类型：

   1) 脏写。即一个事务的没提交之前的修改可以被另外一个事务的修改覆盖掉。(绝不允许！)
   
   2) 脏读。即一个事务的没提交之前的修改被另外一个事务可以看到。
   
   3) 不可重复。指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
   
   4) 幻读。一个事务两次读取，第二次读取读到了另一个事务插入的数据。 （不可重复读是读到了被修改数据，幻读是读到了新增的数据）。
   
   5) 第一类丢失更新，也叫回滚丢失。两个事务同时更新count，事务二出于某种原因更新失败，然后回滚，事务二就把count还原为它一开始读到的值，此时事务一的
更新就这样丢失了。
   
   6) 第二类丢失更新，也叫覆盖丢失。两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，事务二后更新成功并提交并导致事务一的更新丢失了。

2. 数据库提供的四种隔离级别：

   1) Read uncommitted(读未提交)：最低级别，任何情况都会发生。(除了脏写都会发生)
   
   2) Read Committed(读已提交)：可避免脏读的发生。
   
   3) Repeatable read(可重复读)：可避免脏读、不可重复读的发生。
   
   4) Serializable(串行化)：最高的事务隔离级别，代价花费最高，性能很低，很少使用，在此级别下，事务顺序执行，避免脏读、不可重复读，幻读的发生。

### 3.锁

悲观锁：顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。悲观锁分为以下三种：

1.共享锁（又称为读锁和S锁）：也称读锁，事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以同时读，但不能有写操作，直到A释放S锁。

2.排它锁（又称为写锁和X锁）：也称写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。

3.更新锁（简记为U锁）：用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。

  **事务隔离级别**与**锁**的关系：通过对事务的读写操作加锁情况的不同，划分出不同的事务隔离级别。不同的隔离级别就是对事务的读写操作加锁情况的不同。

乐观锁：顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。

乐观锁实现方式：

1.版本号（记为version）：给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version。

2.时间戳（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。

3.待更新字段：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新

字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失

败。

4.所有字段：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

### 4.死锁

### 5.并发修改问题的业务场景

1.有全局数据需要增减。例如的库存数量/垫资额度要扣减。此时应该选择Serializable隔离级别或者手工SELECT … FOR UPDATE加锁。

2.需要读取大量数据。例如业务清算时需要读取一段时间所有的交易记录和资金流水。这种场景不属于OLTP(On-Line Transaction Processing联机事务处理过程)，应该选择Repeatable Read隔离级别得到一个“快照”，并标记事务为只读SET TRANSACTION READ ONLY。这样会让数据库对事务的执行做优化，尽量避免冲突的发生。

3.海量数据插入到OLTP数据库。比如交易系统把每天用户的资产和收益计算后更新到OLTP数据库让用户访问。此时应该实现一个“业务事务”的概念。即不要依靠数据库的业务，而是依靠一个标记。当一个用户的数据正在更新时，应该避免用户看到部分被更新的数据。只有当数据全部更新完了，最后更新一下标记，让数据对用户可见。同时，对数据的更新应该拆解一个个小的事务，避免一个巨大的事务一次性完成更新。

4.特种业务的并发修改。比如共享文档编辑。这种情况下，无法只依靠数据库的并发控制，还必须引入业务级别的冲突检测。

## 索引

一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：**索引是一种数据结构**。

   * B-Tree 是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。
      * B树是一种多路搜索树（并不是二叉的），定义任意非叶子结点最多只有M个儿子；且M>2；
      * 根结点的儿子数为[2, M]；
      * 除根结点以外的非叶子结点的儿子数为[M/2, M]；
      * 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
      * 非叶子结点的关键字个数=指向儿子的指针个数-1；
      * 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
      * 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
      * B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。
      * 所有叶子结点位于同一层；
   * MYSQL使用B+tree 为什么
     * 文件很大，不可能全部存储在内存中，故要存储到磁盘上。索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，局部性原理与磁盘预读，预读的长度一般为页（page）的整倍数（在许多操作系统中，页得大小通常为4k），数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，(由于节点中有两个数组，所以地址连续)。
     * B+树是B-树的变体，也是一种多路搜索树：其定义基本与B-树同
     * 非叶子结点的子树指针与关键字个数相同；
     * 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
     * 为所有叶子结点增加一个链指针；
     * 所有关键字都在叶子结点出现；
   * B+树与B树的区别:
     * B（B-）树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
     * B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
   * 哈希表是另外一种你可能看到用作索引的数据结构-这些索引通常被称为哈希索引。使用哈希索引的原因是，在寻找值时哈希表效率极高
      * 哈希表是无顺的数据结构，对于很多类型的查询语句哈希索引都无能为力。举例来说，假如你想要找出所有小于40岁的员工。你怎么使用使用哈希索引进行查询？这不可行，因为哈希表只适合查询键值对-也就是说查询相等的查询（例：like “WHERE name = ‘Jesus’）。哈希表的键值映射也暗示其键的存储是无序的。这就是为什么哈希索引通常不是数据库索引的默认数据结构-因为在作为索引的数据结构时，其不像B-Tree那么灵活
      
数据库索引是**创建在表的某列上的，并且存储了这一列的所有值**。但是，需要理解的重点是**数据库索引并不存储这个表中其他列（字段）的值。** 如果我们在索引里找到某一条记录作为索引的列的值，如何才能找到这一条记录的其它值呢？这是很简单 - 数据库**索引同时存储了指向表中的相应行的指针**。

**数据库怎么知道什么时候使用索引？**
   * 当这个SQL （SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’）运行时，数据库会检查在查询的列上是否有索引。假设Employee_Name列上确实创建了索引，数据库会接着检查使用这个索引做查询是否合理 - 因为有些场景下，使用索引比起全表扫描会更加低效。
   * 在大多数数据库中（像Oracle 和 MYSQL）， 你实际上可以制订你想要使用的索引。
      * 如何在使用SQL创建索引：在Employee_Name列上创建索引的SQL如下：
`
 CREATEINDEX name_index ON Employee (Employee_Name)
`
      * 我们可以在雇员表上创建两个列的联合索引，SQL如下：
 ```
CREATE INDEX name_index ON Employee (Employee_Name, Employee_Age)
```  
**什么时候不用索引**
1. 表记录太少；
2. 数据重复且分布平均的字段（只有很少数据值的列）；
3. 经常插入、删除、修改的表要减少索引；
4. text，image等类型不应该建立索引，这些列的数据量大（假如text前10个字符唯一，也可以对text前10个字符建立索引）；
### 聚合索引与非聚合索引
1. 聚合索引：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
  * 数据行的物理顺序与列值的顺序相同，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。
  * 聚集索引的好处，索引的叶子节点就是对应的数据节点，可以直接获取到对应的全部列的数据，在查询方面，聚集索引的速度往往会更占优势。
  * 创建方法：
    * 创建表的时候指定主键（注意：SQL Sever默认主键为聚集索引，也可以指定为非聚集索引，而MySQL里主键就是聚集索引）
 `
 create table t1(
    id int primary key,
    name nvarchar(255)
)
 `
    * 或者创建表后添加聚集索引
 `
 create clustered index clustered_index on table_name(colum_name)
 `
2. 非聚合索引: 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。
   * 非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。
   * 如何解决非聚集索引的二次查询问题：可以建立复合索引（覆盖索引）。要注意使用复合索引需要满足最左侧索引的原则，也就是查询的时候如果where条件里面没有最左边的一到多列，索引就不会起作用。
``
select col1, col2 from t1 where col1 = '213';
``

### 索引失效的情况

1. 索引无法存储null值
　　1. 单列索引无法储null值，复合索引无法储全为null的值
　　2. 查询时，采用is null条件时，不能利用到索引，只能全表扫描
2. 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')
   * 假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于前面是模糊的，所以不能利用索引的顺序，必须一个个去找，看是否满足条件。这样会导致全索引扫描或者全表扫描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。
3. 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因),要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。
5. 违反了最佳左前缀法则：
   * MySQL查询时只使用一个索引
   * 一个查询可以只使用索引中的一部分，但只能是最左侧部分
建了一个(a,b,c)的复合索引，那么相当于建了(a),(a,b),(a,b,c)三个索引
   * 结果：
     * 单个查询 a 使用了索引，b c 没有使用索引。(一个查询可以只使用索引中的一部分，但只能是最左侧部分)
     * 部分查询 ab ac ba ca 使用索引,bc cb 没有使用索引。
6. 在索引列上做任何操作（计算，函数，（自动或者手动）类型装换），会导致索引失效而导致全表扫描

### 索引优化

1. 选择区分度高的列作为索引。
2. 在查询远大于插入的列作为索引。
3. 索引列的数据类型越小越好。

### 索引的缺点
1. 提高查询速度，降低更新，插入，删除的速度。
2. 占用磁盘空间。

# 非关系型数据库
