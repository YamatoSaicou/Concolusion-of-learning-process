## 三大范式

## 事务与并发

### 1.事务的特性

事务（transaction）是由指逻辑上对数据的的一组操作。

1. 原子性：事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库，失败则不能对数据库产生影响；

2. 一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

3. 隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离；

4. 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。

### 2.隔离性

隔离性：当多个线程都开启事务来操作数据库中的数据时，数据库系统要进行隔离操作，以保证各个线程获取数据的准确性。

1. 数据访问冲突的类型：

   1) 脏写。即一个事务的没提交之前的修改可以被另外一个事务的修改覆盖掉。(绝不允许！)
   
   2) 脏读。即一个事务的没提交之前的修改被另外一个事务可以看到。
   
   3) 不可重复。指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
   
   4) 幻读。一个事务两次读取，第二次读取读到了另一个事务插入的数据。 （不可重复读是读到了被修改数据，幻读是读到了新增的数据）。
   
   5) 第一类丢失更新，也叫回滚丢失。两个事务同时更新count，事务二出于某种原因更新失败，然后回滚，事务二就把count还原为它一开始读到的值，此时事务一的
更新就这样丢失了。
   
   6) 第二类丢失更新，也叫覆盖丢失。两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，事务二后更新成功并提交并导致事务一的更新丢失了。

2. 数据库提供的四种隔离级别：

   1) Read uncommitted(读未提交)：最低级别，任何情况都会发生。(除了脏写都会发生)
   
   2) Read Committed(读已提交)：可避免脏读的发生。
   
   3) Repeatable read(可重复读)：可避免脏读、不可重复读的发生。
   
   4) Serializable(串行化)：最高的事务隔离级别，代价花费最高，性能很低，很少使用，在此级别下，事务顺序执行，避免脏读、不可重复读，幻读的发生。

### 3.锁

悲观锁：顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。悲观锁分为以下三种：

1.共享锁（又称为读锁和S锁）：也称读锁，事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以同时读，但不能有写操作，直到A释放S锁。

2.排它锁（又称为写锁和X锁）：也称写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。

3.更新锁（简记为U锁）：用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。

  **事务隔离级别**与**锁**的关系：通过对事务的读写操作加锁情况的不同，划分出不同的事务隔离级别。不同的隔离级别就是对事务的读写操作加锁情况的不同。

乐观锁：顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。

乐观锁实现方式：

1.版本号（记为version）：给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version。

2.时间戳（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。

3.待更新字段：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新

字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失

败。

4.所有字段：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

### 4.死锁

### 5.并发修改问题的业务场景

1.有全局数据需要增减。例如的库存数量/垫资额度要扣减。此时应该选择Serializable隔离级别或者手工SELECT … FOR UPDATE加锁。

2.需要读取大量数据。例如业务清算时需要读取一段时间所有的交易记录和资金流水。这种场景不属于OLTP(On-Line Transaction Processing联机事务处理过程)，应该选择Repeatable Read隔离级别得到一个“快照”，并标记事务为只读SET TRANSACTION READ ONLY。这样会让数据库对事务的执行做优化，尽量避免冲突的发生。

3.海量数据插入到OLTP数据库。比如交易系统把每天用户的资产和收益计算后更新到OLTP数据库让用户访问。此时应该实现一个“业务事务”的概念。即不要依靠数据库的业务，而是依靠一个标记。当一个用户的数据正在更新时，应该避免用户看到部分被更新的数据。只有当数据全部更新完了，最后更新一下标记，让数据对用户可见。同时，对数据的更新应该拆解一个个小的事务，避免一个巨大的事务一次性完成更新。

4.特种业务的并发修改。比如共享文档编辑。这种情况下，无法只依靠数据库的并发控制，还必须引入业务级别的冲突检测。

## 索引

