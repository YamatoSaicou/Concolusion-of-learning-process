### 哈希表是什么

散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。

哈希表简单说可以理解成一个映射关系 ，类似 python 语法中字典的键值对。

哈希表是根据键（Key）而直接访问在内存存储位置的数据结构，将任意长度的二进制值串映射为固定长度的二进制值的规则就是哈希算法。原始数据映射得到的二进制值串就是哈希值。

一个优秀的哈希算法主要有以下几点特征 ：

1. 单方向推导 ，不能从哈希值反向推导出原始数据 ，或者说很困难 。
2. 对输入敏感 ，原始数据的微小变化会导致哈希值的大差异 。
3. 散列冲突小 ，不同原始数据得到相同哈希值的概率小 。其实最好是避免 ，但是诸如 MD5 这种也难以彻底避免 ，所以只说尽可能小 。
4. 执行效率高 ，即使是较长的文本 ，也能快速计算出哈希值 。

### 哈希算法能做什么

1. 安全加密。因为优秀的哈希算法具有单方向推导和散列冲突小两个特征 ，这就决定了用来进行安全加密具有很好的应用 。

MD5（MD5 Message-Digest Algorithm ) 和 SHA（Secure Hash Algorithm）就是两个常用于安全加密的哈希算法 。

2. 数据结构。哈希算法在数据结构中用于查找是一个非常不错的方法 ，可以快速定位查找到想要查找的数据信息 。这一用法在刷题的时候遇到的非常多 ！

### 散列函数的构造方法

1. 直接定址法：

``
f(key) = a*key + b(a,b为常数3)
``

  * 优点：简单、均匀，也不会产生冲突。
  * 缺点：需要事先知道关键字的分布情况，适合查找表较小且连续的情况。

2. 平方取中法

   这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。

3. 折叠法

    折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。

    比如关键字是9876543210，散列表表长为三位，将它分为四组，987|654|321|0，然后将它们叠加求和987 + 654 + 321 + 0 = 1962，再求后3位得到散列地址962。

    折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。

### 处理散列冲突

在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。市场会碰到两个关键字key1 != key2，但是却有

f(key1) = f(key2)，这种现象称为冲突。出现冲突将会造成查找错误，因此可以通过精心设计散列函数让冲突尽可能的少，但是不能完全避免。

1. 开放定址法： 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 
  * 散列地址+n，叫做线性探测
  * 散列地址+n^2，叫做二次探测
  * 散列地址+随机队列中的值，叫做随机探测
    * 是随机，那么查找的时候不也随机生成随机值吗？如何取得相同的地址呢？这里的随机其实是伪随机数。伪随机数就是说，如果设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，在查找时，用同样的随机种子，它每次得到的数列是想通的，相同的di 当然可以得到相同的散列地址。
2. 再散列函数法对于散列表来说，可以事先准备多个散列函数。每当发生散列地址冲突时，就换一个散列函数计算。这种方法能够使得关键字不产生聚集，但相应地也增加了计算的时间。
3. 链地址法：将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表，在散列表中只存储所有同义词子表前面的指针。 此时，已经不存在什么冲突换地址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保证。当然，这也就带来了查找时需要遍历单链表的性能损耗。
4. 公共溢出区法：为所有冲突的关键字建立一个公共的溢出区来存放。就前面的例子而言，共有三个关键字37、48、34与之前的关键字位置有冲突，那就将它们存储到溢出表中。在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表中进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。

  
